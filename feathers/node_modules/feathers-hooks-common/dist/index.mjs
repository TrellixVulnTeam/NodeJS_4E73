var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/utils/combine.ts
import { hooks } from "@feathersjs/commons";
var { processHooks } = hooks;
function combine(...serviceHooks) {
  return function(context) {
    return processHooks.call(this, serviceHooks, context);
  };
}

// src/hooks/act-on-dispatch.ts
var actOnDefault = (...hooks2) => actOn(void 0, ...hooks2);
var actOnDispatch = (...hooks2) => actOn("dispatch", ...hooks2);
function actOn(what, ...hooks2) {
  return (context) => {
    const currActOn = context.params._actOn;
    context.params._actOn = what;
    return combine(...hooks2)(context).then((newContext) => {
      newContext.params._actOn = currActOn;
      return newContext;
    });
  };
}

// src/hooks/alter-items.ts
import errors from "@feathersjs/errors";

// src/common/pluck.ts
import _pick from "lodash/pick";
function pluck(items, fieldNames) {
  if (!Array.isArray(items)) {
    return _pick(items, fieldNames);
  }
  const pluckedItems = (Array.isArray(items) ? items : [items]).map((item) => _pick(item, fieldNames));
  return pluckedItems;
}

// src/common/set-fields.ts
import _set from "lodash/set";
function setFields(items, fieldValue, fieldNames, defaultFieldName) {
  const value = typeof fieldValue === "function" ? fieldValue() : fieldValue;
  if (!fieldNames.length)
    fieldNames = [defaultFieldName];
  (Array.isArray(items) ? items : [items]).forEach((item) => {
    fieldNames.forEach((fieldName) => {
      _set(item, fieldName, value);
    });
  });
}

// src/common/transform-items.ts
import _get from "lodash/get";
function transformItems(items, fieldNames, transformer) {
  (Array.isArray(items) ? items : [items]).forEach((item) => {
    fieldNames.forEach((fieldName) => {
      transformer(item, fieldName, _get(item, fieldName));
    });
  });
}

// src/common/traverse.ts
import traverser from "traverse";
function traverse(items, converter) {
  (Array.isArray(items) ? items : [items]).forEach((item) => {
    traverser(item).forEach(converter);
  });
}

// src/common/index.ts
function isPromise(p) {
  return !!p && (typeof p === "object" || typeof p === "function") && typeof p.then === "function";
}

// src/utils/get-items.ts
function getItems(context) {
  if (context.params && context.params._actOn === "dispatch")
    return context.dispatch;
  const items = context.type === "before" ? context.data : context.result;
  return items && context.method === "find" ? items.data || items : items;
}

// src/utils/replace-items.ts
function replaceItems(context, items) {
  if (context.params && context.params._actOn === "dispatch") {
    context.dispatch = items;
    return;
  }
  if (context.type === "before") {
    context.data = items;
  } else if (context.method === "find" && context.result && context.result.data) {
    context.result.data = Array.isArray(items) ? items : [items];
  } else {
    context.result = items;
  }
}

// src/hooks/alter-items.ts
var { BadRequest } = errors;
function alterItems(cb) {
  if (!cb) {
    cb = () => {
    };
  }
  if (typeof cb !== "function") {
    throw new BadRequest("Function required. (alter)");
  }
  return (context) => {
    let items = getItems(context);
    const isArray2 = Array.isArray(items);
    const results = (isArray2 ? items : [items]).map((item) => cb(item, context));
    const hasPromises = results.some((result) => isPromise(result));
    const setItem = (value, index) => {
      if (typeof value === "object" && value !== null) {
        if (isArray2) {
          items[index] = value;
        } else {
          items = value;
        }
      }
    };
    if (hasPromises) {
      return Promise.all(results).then((values) => {
        values.forEach(setItem);
        replaceItems(context, items);
        return context;
      });
    } else {
      results.forEach(setItem);
      replaceItems(context, items);
      return context;
    }
  };
}

// src/hooks/cache.ts
var defaultMakeCacheKey = (key) => key;
function cache(cacheMap, keyField, options) {
  const clone = (options == null ? void 0 : options.clone) || defaultClone;
  const makeCacheKey = (options == null ? void 0 : options.makeCacheKey) || defaultMakeCacheKey;
  return (context) => {
    keyField = keyField || (context.service || {}).id;
    let items = getItems(context);
    items = Array.isArray(items) ? items : [items];
    const query = context.params.query || {};
    if (context.type === "after") {
      if (context.method === "remove") {
        items.forEach((item) => {
          const idName = getIdName(keyField, item);
          const key = makeCacheKey(item[idName]);
          cacheMap.delete(key);
        });
        return;
      }
      if (query.$select)
        return;
      items.forEach((item) => {
        const idName = getIdName(keyField, item);
        const key = makeCacheKey(item[idName]);
        cacheMap.set(key, clone(item));
      });
      return;
    }
    switch (context.method) {
      case "find":
      case "remove":
      case "create":
        return;
      case "get": {
        if (!Object.keys(query).length) {
          const key = makeCacheKey(context.id);
          const value = cacheMap.get(key);
          if (value)
            context.result = value;
        }
        return context;
      }
      default:
        if (context.id) {
          cacheMap.delete(context.id);
          return;
        }
        items.forEach((item) => {
          const idName = getIdName(keyField, item);
          const key = makeCacheKey(item[idName]);
          cacheMap.delete(key);
        });
    }
  };
}
function getIdName(keyField, item) {
  if (keyField)
    return keyField;
  return "_id" in item ? "_id" : "id";
}
function defaultClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// src/utils/check-context.ts
var stndMethods = ["find", "get", "create", "update", "patch", "remove"];
function checkContext(context, type, methods, label = "anonymous") {
  if (type) {
    const types = Array.isArray(type) ? type : [type];
    if (!types.includes(context.type)) {
      throw new Error(`The '${label}' hook can only be used as a '${type}' hook.`);
    }
  }
  if (!methods) {
    return;
  }
  if (stndMethods.indexOf(context.method) === -1) {
    return;
  }
  const myMethods = Array.isArray(methods) ? methods : [methods];
  if (myMethods.length > 0 && myMethods.indexOf(context.method) === -1) {
    const msg = JSON.stringify(myMethods);
    throw new Error(`The '${label}' hook can only be used on the '${msg}' service method(s).`);
  }
}

// src/hooks/check-context-if.ts
function checkContextIf(context, type, methods, label) {
  if (type && context.type === type) {
    checkContext(context, type, methods, label);
  }
}

// src/hooks/debug.ts
function debug(msg, ...fieldNames) {
  return (context) => {
    console.log(`* ${msg || ""}
type:${context.type}, method: ${context.method}`);
    if (context.data) {
      console.log("data:", context.data);
    }
    if (context.params && context.params.query) {
      console.log("query:", context.params.query);
    }
    if (context.result) {
      console.log("result:", context.result);
    }
    const params = context.params || {};
    console.log("params props:", Object.keys(params).sort());
    fieldNames.forEach((name) => {
      console.log(`params.${name}:`, params[name]);
    });
    if (context.error) {
      console.log("error", context.error);
    }
  };
}

// src/hooks/de-populate.ts
import _omit from "lodash/omit";
function dePopulate(func) {
  return (context) => {
    const items = getItems(context);
    const converter = (item) => {
      if (typeof func === "function") {
        func(item);
      }
      const keys = ["_elapsed", "_computed", "_include"];
      const { _computed = [], _include = [] } = item;
      return _omit(item, keys.concat(_computed).concat(_include));
    };
    const converted = Array.isArray(items) ? items.map(converter) : converter(items);
    replaceItems(context, converted);
    return context;
  };
}

// src/hooks/disable-pagination.ts
function disablePagination() {
  return function(context) {
    checkContext(context, "before", ["find"], "disablePagination");
    const $limit = (context.params.query || {}).$limit;
    if ($limit === "-1" || $limit === -1) {
      context.params.paginate = false;
      delete context.params.query.$limit;
    }
    return context;
  };
}

// src/hooks/disallow.ts
import errors2 from "@feathersjs/errors";
var { MethodNotAllowed } = errors2;
function disallow(...transports) {
  return (context) => {
    const hookProvider = (context.params || {}).provider;
    const anyProvider = transports.length === 0;
    const thisProvider = transports.some((provider) => provider === hookProvider || provider === "server" && !hookProvider || provider === "external" && !!hookProvider);
    if (anyProvider || thisProvider) {
      throw new MethodNotAllowed(`Provider '${context.params.provider}' can not call '${context.method}'. (disallow)`);
    }
  };
}

// src/hooks/discard.ts
import _omit2 from "lodash/omit";
function discard(...fieldNames) {
  return (context) => {
    checkContextIf(context, "before", ["create", "update", "patch"], "discard");
    const items = getItems(context);
    const convert = (item) => _omit2(item, fieldNames);
    const converted = Array.isArray(items) ? items.map(convert) : convert(items);
    replaceItems(context, converted);
    return context;
  };
}

// src/hooks/discard-query.ts
import _omit3 from "lodash/omit";
function discardQuery(...fieldNames) {
  return (context) => {
    checkContext(context, "before", null, "discardQuery");
    const query = (context.params || {}).query || {};
    context.params.query = _omit3(query, fieldNames);
    return context;
  };
}

// src/hooks/fast-join.ts
function fastJoin(resolvers, query) {
  return (context) => {
    const { method, data, result, params } = context;
    if (params._populate || params._graphql)
      return context;
    const q = typeof query === "function" ? query(context) : query;
    const joins2 = typeof resolvers === "function" ? resolvers(context) : resolvers;
    const { before, joins, after } = joins2;
    const temp = result || (Array.isArray(data) ? data : [data]);
    const results = method === "find" ? result.data || temp : temp;
    const prevLoaders = context._loaders;
    context._loaders = {};
    return Promise.resolve().then(() => before && before(context)).then(() => joins && results && recursive(joinsForQuery(joins2, q, context), results, context)).then(() => after && after(context)).then(() => {
      context._loaders = prevLoaders;
      return context;
    });
  };
}
function joinsForQuery({
  joins
} = {}, query = void 0, context = {}) {
  const runtime = [];
  Object.keys(joins).forEach((outerLabel) => {
    if (query && !query[outerLabel])
      return;
    let join = joins[outerLabel];
    if (typeof join === "function") {
      join = { resolver: join };
    }
    const { resolver } = join;
    let { joins: innerJoins } = join;
    if (innerJoins && !innerJoins.resolver && innerJoins.joins) {
      innerJoins = innerJoins.joins;
    }
    let args = query ? query[outerLabel] : [];
    if (!Array.isArray(args)) {
      args = typeof args === "object" && args !== null ? args.args : [];
    }
    runtime.push({
      args,
      resolver,
      joins: innerJoins ? joinsForQuery({ joins: innerJoins }, query ? query[outerLabel] : null, context) : null
    });
  });
  return runtime;
}
function recursive(joins, results, context) {
  return Promise.all((Array.isArray(results) ? results : [results]).map((result) => Promise.all(joins.map(({
    args = [],
    resolver,
    joins: joins2
  }) => {
    return Promise.resolve(resolver(...args)(result, context)).then((addedResults) => {
      if (!addedResults || !joins2)
        return context;
      return recursive(joins2, addedResults, context);
    });
  }))));
}

// src/hooks/fgraphql.ts
import makeDebug from "debug";
var debug2 = makeDebug("fgraphql");
var graphqlActions = ["Query", "Mutation", "Subscription"];
function fgraphql(options1) {
  debug2("init call");
  const { parse, recordType, resolvers, runTime, query } = options1;
  let { schema } = options1;
  let ourResolvers;
  const options = Object.assign({}, {
    skipHookWhen: (context) => !!(context.params || {}).graphql,
    inclAllFieldsServer: true,
    inclAllFieldsClient: true,
    inclAllFields: null,
    inclJoinedNames: true,
    extraAuthProps: []
  }, options1.options || {});
  schema = isFunction(schema) ? schema() : schema;
  if (!isObject(schema) && !isString(schema)) {
    throwError(`Resolved schema is typeof ${typeof schema} rather than string or object. (fgraphql)`, 101);
  }
  if (!isObject(runTime)) {
    throwError(`option runTime is typeof ${typeof runTime} rather than an object. (fgraphql)`, 106);
  }
  if (!isString(recordType)) {
    throwError(`recordType is typeof ${typeof recordType} rather than string. (fgraphql)`, 103);
  }
  if (!isArray(options.extraAuthProps)) {
    throwError(`option extraAuthProps is typeof ${typeof options.extraAuthProps} rather than array. (fgraphql)`, 105);
  }
  const feathersSdl = isObject(schema) ? schema : convertSdlToFeathersSchemaObject(schema, parse);
  debug2("schema now in internal form");
  return (context) => {
    const contextParams = context.params;
    const optSkipHookWhen = options.skipHookWhen;
    const skipHookWhen = isFunction(optSkipHookWhen) ? optSkipHookWhen(context) : optSkipHookWhen;
    debug2(`
.....hook called. type ${context.type} method ${context.method} resolved skipHookWhen ${skipHookWhen}`);
    if (context.params.$populate)
      return context;
    if (skipHookWhen)
      return context;
    const q = isFunction(query) ? query(context) : query;
    if (!isObject(q)) {
      throwError(`Resolved query is typeof ${typeof q} rather than object. (fgraphql)`, 102);
    }
    if (!ourResolvers) {
      ourResolvers = resolvers(context.app, runTime);
      debug2(`ourResolvers has Types ${Object.keys(ourResolvers)}`);
    }
    if (!ourResolvers[recordType]) {
      throwError(`recordType ${recordType} not found in resolvers. (fgraphql)`, 104);
    }
    options.inclAllFields = contextParams.provider ? options.inclAllFieldsClient : options.inclAllFieldsServer;
    debug2(`inclAllField ${options.inclAllFields}`);
    const resolverContent = {
      app: context.app,
      provider: contextParams.provider,
      user: contextParams.user,
      authenticated: contextParams.authenticated,
      batchLoaders: {},
      cache: {}
    };
    (options.extraAuthProps || []).forEach((name) => {
      if (name in contextParams && !(name in resolverContent)) {
        resolverContent[name] = contextParams[name];
      }
    });
    const store = {
      feathersSdl,
      ourResolvers,
      options,
      resolverContent
    };
    const recs = getItems(context);
    return processRecords(store, q, recs, recordType).then(() => {
      replaceItems(context, recs);
      return context;
    });
  };
}
function processRecords(store, query, recs, type, depth = 0) {
  if (!recs)
    return;
  recs = isArray(recs) ? recs : [recs];
  debug2(`
vvvvvvvvvv enter ${depth}`);
  debug2(`processRecords depth ${depth} #recs ${recs.length} Type ${type}`);
  const storeOurResolversType = store.ourResolvers[type];
  if (!isObject(storeOurResolversType)) {
    throwError(`Resolvers for Type ${type} are typeof ${typeof storeOurResolversType} not object. (fgraphql)`, 201);
  }
  if (!isObject(query)) {
    throwError(`query at Type ${type} are typeof ${typeof query} not object. (fgraphql)`, 202);
  }
  return Promise.all(recs.map((rec, j) => processRecord(store, query, depth, rec, type, j))).then(() => {
    debug2(`^^^^^^^^^^ exit ${depth}
`);
  });
}
function processRecord(store, query, depth, rec, type, j) {
  debug2(`processRecord rec# ${j} typeof ${typeof rec} Type ${type}`);
  if (!rec)
    return;
  const queryPropNames = Object.keys(query);
  const recFieldNamesInQuery = [];
  const joinedNamesInQuery = [];
  return Promise.all(queryPropNames.map((fieldName, i) => processRecordQuery(store, query, depth, rec, fieldName, type, recFieldNamesInQuery, joinedNamesInQuery, j, i))).then(() => {
    debug2(`field names found ${recFieldNamesInQuery} joined names ${joinedNamesInQuery}`);
    if (recFieldNamesInQuery.length || !store.options.inclAllFields || queryPropNames.includes("_none")) {
      Object.keys(rec).forEach((key) => {
        if (!recFieldNamesInQuery.includes(key) && !joinedNamesInQuery.includes(key)) {
          delete rec[key];
        }
      });
    }
    if (store.options.inclJoinedNames && joinedNamesInQuery.length) {
      rec._include = joinedNamesInQuery;
    }
  });
}
function processRecordQuery(store, query, depth, rec, fieldName, type, recFieldNamesInQuery, joinedNamesInQuery, j, i) {
  debug2(`
processRecordQuery rec# ${j} Type ${type} field# ${i} name ${fieldName}`);
  if (query[fieldName] && fieldName !== "_args" && fieldName !== "_none") {
    if (store.ourResolvers[type][fieldName]) {
      joinedNamesInQuery.push(fieldName);
      return processRecordFieldResolver(store, query, depth, rec, fieldName, type);
    } else {
      debug2("is not resolver call");
      recFieldNamesInQuery.push(fieldName);
    }
  }
}
function processRecordFieldResolver(store, query, depth, rec, fieldName, type) {
  debug2("is resolver call");
  const ourQuery = store.feathersSdl[type][fieldName];
  const ourResolver = store.ourResolvers[type][fieldName];
  if (!isFunction(ourResolver)) {
    throwError(`Resolver for Type ${type} fieldName ${fieldName} is typeof ${typeof ourResolver} not function. (fgraphql)`, 203);
  }
  const args = isObject(query[fieldName]) ? query[fieldName]._args : void 0;
  debug2(`resolver listType ${ourQuery.listType} args ${JSON.stringify(args)}`);
  return Promise.resolve(ourResolver(rec, args || {}, store.resolverContent)).then(async (rawResult) => {
    debug2(`resolver returned typeof ${isArray(rawResult) ? `array #recs ${rawResult.length}` : typeof rawResult}`);
    const result = convertResolverResult(rawResult, ourQuery, fieldName, type);
    if (isArray(rawResult !== isArray(result) || typeof rawResult !== typeof result)) {
      debug2(`.....resolver result converted to typeof ${isArray(result) ? `array #recs ${result.length}` : typeof result}`);
    }
    rec[fieldName] = result;
    const nextType = ourQuery.typeof;
    debug2(`Type ${type} fieldName ${fieldName} next Type ${nextType}`);
    if (store.ourResolvers[nextType] && isObject(query[fieldName])) {
      return processRecords(store, query[fieldName], result, nextType, depth + 1);
    } else {
      debug2("no population of results required");
    }
  });
}
function convertResolverResult(result, ourQuery, fieldName, type) {
  if (result === null || result === void 0) {
    return ourQuery.listType ? [] : null;
  }
  if (ourQuery.listType) {
    if (!isArray(result))
      return [result];
  } else if (isArray(result)) {
    if (result.length > 1) {
      throwError(`Query listType true. Resolver for Type ${type} fieldName ${fieldName} result is array len ${result.length} (fgraphql)`, 204);
    }
    return result[0];
  }
  return result;
}
function convertSdlToFeathersSchemaObject(schemaDefinitionLanguage, parse) {
  const graphQLSchemaObj = parse(schemaDefinitionLanguage);
  return convertDocument(graphQLSchemaObj);
}
function convertDocument(ast) {
  const result = {};
  if (ast.kind !== "Document" || !isArray(ast.definitions)) {
    throw new Error("Not a valid GraphQL Document.");
  }
  ast.definitions.forEach((definition, definitionIndex) => {
    const [objectName, converted] = convertObjectTypeDefinition(definition, definitionIndex);
    if (objectName) {
      result[objectName] = converted;
    }
  });
  return result;
}
function convertObjectTypeDefinition(definition, definitionIndex) {
  const converted = {};
  if (definition.kind !== "ObjectTypeDefinition" || !isArray(definition.fields)) {
    throw new Error(`Type# ${definitionIndex} is not a valid ObjectTypeDefinition`);
  }
  const objectTypeName = convertName(definition.name, `Type# ${definitionIndex}`);
  if (graphqlActions.includes(objectTypeName))
    return [null, null];
  definition.fields.forEach((field) => {
    const [fieldName, fieldDefinition] = convertFieldDefinition(field, `Type ${objectTypeName}`);
    converted[fieldName] = fieldDefinition;
  });
  return [objectTypeName, converted];
}
function convertName(nameObj, errDesc) {
  if (!isObject(nameObj) || !isString(nameObj.value)) {
    throw new Error(`${errDesc} does not have a valid name prop.`);
  }
  return nameObj.value;
}
function convertFieldDefinition(field, errDesc) {
  if (field.kind !== "FieldDefinition" || !isObject(field.type)) {
    throw new Error(`${errDesc} is not a valid ObjectTypeDefinition`);
  }
  const fieldName = convertName(field.name, errDesc);
  const converted = convertFieldDefinitionType(field.type, errDesc);
  converted.inputValues = field.arguments && field.arguments.length !== 0;
  return [fieldName, converted];
}
function convertFieldDefinitionType(fieldDefinitionType, errDesc, converted) {
  converted = converted || { nonNullTypeList: false, listType: false, nonNullTypeField: false, typeof: null };
  if (!isObject(fieldDefinitionType)) {
    throw new Error(`${errDesc} is not a valid Fielddefinition "type".`);
  }
  switch (fieldDefinitionType.kind) {
    case "NamedType":
      converted.typeof = convertName(fieldDefinitionType.name);
      return converted;
    case "NonNullType":
      if (fieldDefinitionType.type.kind === "NamedType") {
        converted.nonNullTypeField = true;
      } else {
        converted.nonNullTypeList = true;
      }
      return convertFieldDefinitionType(fieldDefinitionType.type, errDesc, converted);
    case "ListType":
      converted.listType = true;
      return convertFieldDefinitionType(fieldDefinitionType.type, errDesc, converted);
  }
}
function throwError(msg, code) {
  const err = new Error(msg);
  err.code = code;
  throw err;
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}
function isString(str) {
  return typeof str === "string";
}
function isFunction(func) {
  return typeof func === "function";
}
function isArray(array) {
  return Array.isArray(array);
}

// src/hooks/iff-else.ts
function iffElse(predicate, trueHooks, falseHooks) {
  return function(ctx) {
    if (typeof trueHooks === "function") {
      trueHooks = [trueHooks];
    }
    if (typeof falseHooks === "function") {
      falseHooks = [falseHooks];
    }
    const that = this;
    const check = typeof predicate === "function" ? predicate.apply(that, [ctx]) : !!predicate;
    if (!check) {
      return callHooks.call(that, ctx, falseHooks);
    }
    if (!isPromise(check)) {
      return callHooks.call(that, ctx, trueHooks);
    }
    return check.then((check1) => {
      const hooks2 = check1 ? trueHooks : falseHooks;
      return callHooks.call(that, ctx, hooks2);
    });
  };
}
function callHooks(ctx, serviceHooks) {
  let hooks2 = serviceHooks;
  if (serviceHooks && serviceHooks.length && Array.isArray(serviceHooks[0])) {
    hooks2 = serviceHooks[0];
  }
  return hooks2 ? combine(...hooks2).call(this, ctx) : ctx;
}

// src/hooks/iff.ts
function iff(predicate, ...hooks2) {
  const iffWithoutElse = function(context) {
    return iffElse(predicate, hooks2.slice())(context);
  };
  iffWithoutElse.else = (...falseHooks) => (context) => iffElse(predicate, hooks2.slice(), falseHooks.slice())(context);
  return iffWithoutElse;
}

// src/utils/is-provider.ts
import errors3 from "@feathersjs/errors";
var { MethodNotAllowed: MethodNotAllowed2 } = errors3;
function isProvider(...providers) {
  if (!providers.length) {
    throw new MethodNotAllowed2("Calling iff() predicate incorrectly. (isProvider)");
  }
  return (context) => {
    const hookProvider = (context.params || {}).provider;
    return providers.some((provider) => provider === hookProvider || provider === "server" && !hookProvider || provider === "external" && !!hookProvider);
  };
}

// src/hooks/keep.ts
import _get2 from "lodash/get";
import _set2 from "lodash/set";
import _has from "lodash/has";
function keep(...fieldNames) {
  return (context) => {
    checkContextIf(context, "before", ["create", "update", "patch"], "keep");
    const items = getItems(context);
    if (Array.isArray(items)) {
      replaceItems(context, items.map((item) => replaceItem(item, fieldNames)));
    } else {
      replaceItems(context, replaceItem(items, fieldNames));
    }
    return context;
  };
}
function replaceItem(item, fields) {
  if (typeof item !== "object" || item === null)
    return item;
  const newItem = {};
  fields.forEach((field) => {
    if (!_has(item, field))
      return;
    const value = _get2(item, field);
    _set2(newItem, field, value);
  });
  item = newItem;
  return item;
}

// src/hooks/keep-in-array.ts
import errors4 from "@feathersjs/errors";
import _get3 from "lodash/get";
import _set3 from "lodash/set";
import _has2 from "lodash/has";
var { BadRequest: BadRequest2 } = errors4;
function keepInArray(arrayName, fieldNames) {
  return (context) => {
    const items = getItems(context);
    if (Array.isArray(items)) {
      items.forEach((item) => replaceIn(item, arrayName, fieldNames));
    } else {
      replaceIn(items, arrayName, fieldNames);
    }
    return context;
  };
}
function replaceIn(item, field, fieldNames) {
  const target = _get3(item, field);
  if (target) {
    if (!Array.isArray(target))
      throw new BadRequest2(`The 'field' param must lead to array. found type '${typeof target}' instead`);
    _set3(item, field, target.map((item2) => replaceItem2(item2, fieldNames)));
  }
}
function replaceItem2(item, fields) {
  if (typeof item !== "object" || item === null)
    return item;
  const newItem = {};
  fields.forEach((field) => {
    if (!_has2(item, field))
      return;
    const value = _get3(item, field);
    _set3(newItem, field, value);
  });
  item = newItem;
  return item;
}

// src/hooks/keep-query.ts
function keepQuery(...fieldNames) {
  return (context) => {
    checkContext(context, "before", null, "keepQuery");
    const query = (context.params || {}).query || {};
    context.params.query = pluck(query, fieldNames);
    return context;
  };
}

// src/hooks/keep-query-in-array.ts
import errors5 from "@feathersjs/errors";
import _get4 from "lodash/get";
import _set4 from "lodash/set";
import _has3 from "lodash/has";
var { BadRequest: BadRequest3 } = errors5;
function keepQueryInArray(arrayName, fieldNames) {
  return (context) => {
    checkContext(context, "before", null, "keepQueryInArray");
    replaceIn2(context.query, arrayName, fieldNames);
    return context;
  };
}
function replaceIn2(item, field, fieldNames) {
  const target = _get4(item, field);
  if (target) {
    if (!Array.isArray(target))
      throw new BadRequest3(`The 'field' param must lead to array. found type '${typeof target}' instead`);
    _set4(item, field, target.map((item2) => replaceItem3(item2, fieldNames)));
  }
}
function replaceItem3(item, fields) {
  if (typeof item !== "object" || item === null)
    return item;
  const newItem = {};
  fields.forEach((field) => {
    if (!_has3(item, field))
      return;
    const value = _get4(item, field);
    _set4(newItem, field, value);
  });
  item = newItem;
  return item;
}

// src/hooks/lower-case.ts
import _set5 from "lodash/set";
import errors6 from "@feathersjs/errors";
var { BadRequest: BadRequest4 } = errors6;
function lowerCase(...fieldNames) {
  return (context) => {
    checkContextIf(context, "before", ["create", "update", "patch"], "lowercase");
    transformItems(getItems(context), fieldNames, (item, fieldName, value) => {
      if (value !== void 0) {
        if (typeof value !== "string" && value !== null) {
          throw new BadRequest4(`Expected string data. (lowercase ${fieldName})`);
        }
        _set5(item, fieldName, value ? value.toLowerCase() : value);
      }
    });
    return context;
  };
}

// src/hooks/mongo-keys.ts
import traverse2 from "traverse";
function mongoKeys(ObjectId, keyFields) {
  keyFields = Array.isArray(keyFields) ? keyFields : [keyFields];
  const keyLeaves = [];
  const keysInfo = keyFields.map((field) => {
    const fieldNames = field.split(".");
    const leaf = fieldNames.slice(-1)[0];
    keyLeaves.push(leaf);
    return { leaf, len: fieldNames.length, path: JSON.stringify(fieldNames) };
  });
  return (context) => {
    checkContext(context, "before", null, "mongoKeys");
    const query = context.params.query || {};
    traverse2(query).forEach(function(node) {
      const typeofNode = typeof node;
      const key = this.key;
      const path = this.path;
      if (keyLeaves.indexOf(key) === -1)
        return;
      if (path.indexOf("$sort") !== -1)
        return;
      keysInfo.forEach((info) => {
        if (info.leaf === key && info.len <= path.length) {
          const endPath = path.slice(-info.len);
          if (JSON.stringify(endPath) === info.path) {
            if (typeofNode === "object" && node !== null && !Array.isArray(node)) {
              const actualProps = Object.keys(node);
              const onlyProp = actualProps[0];
              if (actualProps.length === 1 && onlyProp === "$in") {
                const newNode = { $in: wrapValue(node[onlyProp]) };
                this.update(newNode);
              }
            } else if (typeofNode === "string" || typeofNode === "number") {
              const newNode = wrapValue(node);
              this.update(newNode);
            }
          }
        }
      });
    });
    return context;
  };
  function wrapValue(value) {
    return Array.isArray(value) ? value.map((val) => new ObjectId(val)) : new ObjectId(value);
  }
}

// src/hooks/params-from-client.ts
function paramsFromClient(...whitelist) {
  return (context) => {
    const params = context.params;
    if (params && params.query && params.query.$client && typeof params.query.$client === "object") {
      const client = params.query.$client;
      whitelist.forEach((key) => {
        if (key in client) {
          params[key] = client[key];
        }
      });
      params.query = Object.assign({}, params.query);
      delete params.query.$client;
    }
    return context;
  };
}

// src/hooks/populate.ts
import _get5 from "lodash/get";
import _set6 from "lodash/set";
import errors7 from "@feathersjs/errors";
var { BadRequest: BadRequest5 } = errors7;
function populate(options) {
  const typeofSchema = typeof options.schema;
  if ((typeofSchema !== "object" || options.schema === null) && typeofSchema !== "function") {
    throw new Error("Options.schema is not an object. (populate)");
  }
  return function(context) {
    const optionsDefault = {
      schema: {},
      checkPermissions: () => true,
      profile: false
    };
    if (context.params._populate === "skip") {
      return context;
    }
    return Promise.resolve().then(() => {
      const items = getItems(context);
      const options1 = Object.assign({}, optionsDefault, options);
      const { schema, checkPermissions } = options1;
      const schema1 = typeof schema === "function" ? schema(context, options1) : schema;
      const permissions = schema1.permissions || null;
      const baseService = schema1.service;
      const provider = "provider" in schema1 ? schema1.provider : context.params.provider;
      if (typeof checkPermissions !== "function") {
        throw new BadRequest5("Permissions param is not a function. (populate)");
      }
      if (baseService && context.path && baseService !== context.path) {
        throw new BadRequest5(`Schema is for ${baseService} not ${context.path}. (populate)`);
      }
      if (permissions && !checkPermissions(context, context.path, permissions, 0)) {
        throw new BadRequest5("Permissions do not allow this populate. (populate)");
      }
      if (typeof schema1 !== "object") {
        throw new BadRequest5("Schema does not resolve to an object. (populate)");
      }
      const include = [].concat(schema1.include || []).map((schema2) => {
        if ("provider" in schema2) {
          return schema2;
        } else {
          return Object.assign({}, schema2, { provider });
        }
      });
      return !include.length ? items : populateItemArray(options1, context, items, include, 0);
    }).then((items) => {
      replaceItems(context, items);
      return context;
    });
  };
}
function populateItemArray(options, context, items, includeSchema, depth) {
  if (items.toJSON || items.toObject) {
    throw new BadRequest5("Populate requires results to be plain JavaScript objects. (populate)");
  }
  if (!Array.isArray(items)) {
    return populateItem(options, context, items, includeSchema, depth + 1);
  }
  return Promise.all(items.map((item) => populateItem(options, context, item, includeSchema, depth + 1)));
}
function populateItem(options, context, item, includeSchema, depth) {
  const elapsed = {};
  const startAtAllIncludes = new Date().getTime();
  const include = [].concat(includeSchema || []);
  if (!Object.prototype.hasOwnProperty.call(item, "_include"))
    item._include = [];
  return Promise.all(include.map((childSchema) => {
    const { query, select, parentField } = childSchema;
    if (!query && !select && (!parentField || _get5(item, parentField) === void 0)) {
      return void 0;
    }
    const startAtThisInclude = new Date().getTime();
    return populateAddChild(options, context, item, childSchema, depth).then((result) => {
      const nameAs = childSchema.nameAs || childSchema.service;
      elapsed[nameAs] = getElapsed(options, startAtThisInclude, depth);
      return result;
    });
  })).then((children) => {
    if (options.profile !== false) {
      elapsed.total = getElapsed(options, startAtAllIncludes, depth);
      item._elapsed = elapsed;
    }
    children.forEach((child) => {
      if (child) {
        _set6(item, child.nameAs, child.items);
      }
    });
    return item;
  });
}
function populateAddChild(options, context, parentItem, childSchema, depth) {
  const {
    childField,
    paginate,
    parentField,
    permissions,
    query,
    select,
    service,
    useInnerPopulate,
    provider
  } = childSchema;
  if (!service) {
    throw new BadRequest5("Child schema is missing the service property. (populate)");
  }
  if (!query && !select && !(parentField && childField)) {
    throw new BadRequest5("Child schema is missing parentField or childField property. (populate)");
  }
  if (permissions && !options.checkPermissions(context, service, permissions, depth)) {
    throw new BadRequest5(`Permissions for ${service} do not allow include. (populate)`);
  }
  const nameAs = childSchema.nameAs || service;
  if (parentItem._include.indexOf(nameAs) === -1)
    parentItem._include.push(nameAs);
  return Promise.resolve().then(() => select ? select(context, parentItem, depth) : {}).then((selectQuery) => {
    let sqlQuery = {};
    if (parentField) {
      const parentVal = _get5(parentItem, parentField);
      sqlQuery = { [childField]: Array.isArray(parentVal) ? { $in: parentVal } : parentVal };
    }
    const queryObj = Object.assign({}, query, sqlQuery, selectQuery);
    const serviceHandle = context.app.service(service);
    if (!serviceHandle) {
      throw new BadRequest5(`Service ${service} is not configured. (populate)`);
    }
    let paginateObj = { paginate: false };
    const paginateOption = paginate;
    if (paginateOption === true) {
      paginateObj = null;
    }
    if (typeof paginateOption === "number") {
      paginateObj = { paginate: { default: paginateOption } };
    }
    const params = Object.assign({}, context.params, paginateObj, { query: queryObj }, useInnerPopulate ? {} : { _populate: "skip" }, "provider" in childSchema ? { provider: childSchema.provider } : {});
    return serviceHandle.find(params);
  }).then((result) => {
    result = result.data || result;
    if (result.length === 0) {
      return childSchema.asArray ? [] : null;
    }
    if (result.length === 1 && !childSchema.asArray) {
      result = result[0];
    }
    const include = [].concat(childSchema.include || []).map((schema) => {
      if ("provider" in schema) {
        return schema;
      } else {
        return Object.assign({}, schema, { provider });
      }
    });
    return childSchema.include && result ? populateItemArray(options, context, result, include, depth) : result;
  }).then((items) => ({ nameAs, items }));
}
function milliToNano(num) {
  return num * 1e6;
}
function getElapsed(options, startTime, depth) {
  if (options.profile === true) {
    return milliToNano(new Date().getTime() - startTime + 1e-3);
  }
  return depth;
}

// src/hooks/prevent-changes.ts
import _has4 from "lodash/has";
import _omit4 from "lodash/omit";
import errors8 from "@feathersjs/errors";
var { BadRequest: BadRequest6 } = errors8;
function preventChanges(ifThrow, ...fieldNames) {
  if (typeof ifThrow === "string") {
    console.warn("**Deprecated** Use the preventChanges(true, ...fieldNames) syntax instead.");
    fieldNames = [ifThrow, ...fieldNames];
  }
  return (context) => {
    checkContext(context, "before", ["patch"], "preventChanges");
    const { data } = context;
    fieldNames.forEach((name) => {
      if (_has4(data, name)) {
        if (ifThrow) {
          throw new BadRequest6(`Field ${name} may not be patched. (preventChanges)`);
        }
        context.data = _omit4(data, name);
      }
    });
    return context;
  };
}

// src/hooks/required.ts
import _get6 from "lodash/get";
import errors9 from "@feathersjs/errors";
import _has5 from "lodash/has";
var { BadRequest: BadRequest7 } = errors9;
function required(...fieldNames) {
  return (context) => {
    checkContext(context, "before", ["create", "update", "patch"], "required");
    const items = getItems(context);
    (Array.isArray(items) ? items : [items]).forEach((item) => {
      fieldNames.forEach((name) => {
        if (!_has5(item, name))
          throw new BadRequest7(`Field ${name} does not exist. (required)`);
        const value = _get6(item, name);
        if (!value && value !== 0 && value !== false)
          throw new BadRequest7(`Field ${name} is null. (required)`);
      });
    });
  };
}

// src/utils/run-hook.ts
function runHook(context) {
  const extraContent = context;
  return (hookFunc) => (result) => {
    const ctx = Object.assign({}, { type: "after", params: {}, result }, extraContent);
    if (typeof result === "object" && result !== null && result.total && result.data) {
      ctx.method = "find";
    }
    return Promise.resolve().then(() => hookFunc(ctx)).then((newContext) => {
      if (newContext === void 0) {
        return;
      }
      const result2 = newContext.result;
      if (typeof result2 === "object" && result2 !== null && result2.total && result2.data) {
        return newContext.result;
      }
      return newContext.result.data || newContext.result;
    });
  };
}

// src/hooks/run-parallel.ts
import errors10 from "@feathersjs/errors";
var { BadRequest: BadRequest8 } = errors10;
function runParallel(hook, clone, cloneDepth = 6) {
  if (typeof hook !== "function") {
    throw new BadRequest8("Function not provided. (runParallel)");
  }
  return function(context) {
    const copy = cloneDepth ? clone(context) : context;
    setTimeout(() => hook.call(this, copy));
  };
}

// src/hooks/sequelize-convert.ts
var methodsWithBeforeData = ["create", "update", "patch"];
var defaultConversions = {
  boolean: {
    sql: (boolean) => boolean ? 1 : 0,
    js: (numb) => !!numb
  },
  date: {
    sql: (dateNow) => dateNow,
    js: (sqlDate) => new Date(sqlDate).valueOf() || null
  },
  json: {
    sql: (obj) => JSON.stringify(obj),
    js: (str) => JSON.parse(str)
  }
};
function sequelizeConvert(converts, ignores, conversions) {
  const converter = sequelizeConversion(converts, ignores, conversions);
  return (context) => {
    if (context.type === "before" && !methodsWithBeforeData.includes(context.method))
      return context;
    const items = getItems(context);
    converter(context.type === "before" ? "sql" : "js", items);
    replaceItems(context, items);
    return context;
  };
}
function sequelizeConversion(converts, ignores, conversions = {}) {
  converts = converts || {};
  ignores = ignores || [];
  conversions.boolean = conversions.boolean || defaultConversions.boolean;
  conversions.date = conversions.date || defaultConversions.date;
  conversions.json = conversions.json || defaultConversions.json;
  const props = Object.keys(converts).filter((name) => !ignores.includes(name));
  return (sqlJs, recs) => {
    recs = Array.isArray(recs) ? recs : [recs];
    recs.forEach((rec) => {
      props.forEach((name) => {
        if (name in rec) {
          rec[name] = conversions[converts[name].toLowerCase()][sqlJs](rec[name]);
        }
      });
    });
  };
}

// src/hooks/serialize.ts
import _get7 from "lodash/get";
import _set7 from "lodash/set";
import _omit5 from "lodash/omit";
function serialize(schema1) {
  return (context) => {
    const schema = typeof schema1 === "function" ? schema1(context) : schema1;
    const schemaDirectives = ["computed", "exclude", "only"];
    replaceItems(context, serializeItems(getItems(context), schema));
    return context;
    function serializeItems(items, schema2) {
      if (!Array.isArray(items)) {
        return serializeItem(items, schema2);
      }
      return items.map((item) => serializeItem(item, schema2));
    }
    function serializeItem(item, schema2) {
      const computed = {};
      Object.keys(schema2.computed || {}).forEach((name) => {
        computed[name] = schema2.computed[name](item, context);
      });
      let only = schema2.only;
      only = typeof only === "string" ? [only] : only;
      if (only) {
        const newItem = {};
        only.concat("_include", "_elapsed", item._include || []).forEach((key) => {
          const value = _get7(item, key);
          if (value !== void 0) {
            _set7(newItem, key, value);
          }
        });
        item = newItem;
      }
      let exclude = schema2.exclude;
      exclude = typeof exclude === "string" ? [exclude] : exclude;
      if (exclude) {
        item = _omit5(item, exclude);
      }
      const _computed = Object.keys(computed);
      item = Object.assign({}, item, computed, _computed.length ? { _computed } : {});
      Object.keys(schema2).forEach((key) => {
        if (!schemaDirectives.includes(key) && typeof item[key] === "object") {
          item[key] = serializeItems(item[key], schema2[key]);
        }
      });
      return item;
    }
  };
}

// src/hooks/set-field.ts
import _get8 from "lodash/get";
import _setWith from "lodash/setWith";
import _clone from "lodash/clone";
import _debug from "debug";
import errors11 from "@feathersjs/errors";
var { Forbidden } = errors11;
var debug3 = _debug("feathers-hooks-common/setField");
function setField({ as, from, allowUndefined = false }) {
  if (!as || !from) {
    throw new Error("'as' and 'from' options have to be set");
  }
  return (context) => {
    const { params, app } = context;
    if (app.version < "4.0.0") {
      throw new Error("The 'setField' hook only works with Feathers 4 and the latest database adapters");
    }
    checkContext(context, "before", null, "setField");
    const value = _get8(context, from);
    if (value === void 0) {
      if (!params.provider || allowUndefined) {
        debug3(`Skipping call with value ${from} not set`);
        return context;
      }
      throw new Forbidden(`Expected field ${as} not available`);
    }
    debug3(`Setting value '${value}' from '${from}' as '${as}'`);
    return _setWith(context, as, value, _clone);
  };
}

// src/hooks/set-now.ts
import errors12 from "@feathersjs/errors";
var { BadRequest: BadRequest9 } = errors12;
function setNow(...fieldNames) {
  if (!fieldNames.length) {
    throw new BadRequest9("Field name is required. (setNow)");
  }
  return (context) => {
    setFields(getItems(context), () => new Date(), fieldNames, "setNow");
    return context;
  };
}

// src/hooks/set-slug.ts
import _set8 from "lodash/set";
import errors13 from "@feathersjs/errors";
var { GeneralError } = errors13;
function setSlug(slug, fieldName) {
  return (context) => {
    if (typeof fieldName !== "string") {
      fieldName = `query.${slug}`;
    }
    if (context.type === "after") {
      throw new GeneralError("Cannot set slug on after hook. (setSlug)");
    }
    if (context.params && context.params.provider === "rest") {
      const value = context.params.route[slug];
      if (typeof value === "string" && value[0] !== ":") {
        _set8(context.params, fieldName, value);
      }
    }
  };
}

// src/hooks/sifter.ts
import errors14 from "@feathersjs/errors";
var { BadRequest: BadRequest10 } = errors14;
function sifter(siftFunc) {
  return (context) => {
    checkContext(context, "after", "find", "sifter");
    if (typeof siftFunc !== "function") {
      throw new BadRequest10("The sifter param must be a function. (sifter)");
    }
    const sifter2 = siftFunc(context);
    if (typeof sifter2 !== "function") {
      throw new BadRequest10("The result of calling the sifter param must be a function. (sifter)");
    }
    replaceItems(context, getItems(context).filter(sifter2));
    return context;
  };
}

// src/hooks/soft-delete.ts
import errors15 from "@feathersjs/errors";
var { GeneralError: GeneralError2 } = errors15;
var defaultQuery = { deleted: { $ne: true } };
var defaultData = { deleted: true };
var getValue = (value, ...args) => {
  if (typeof value === "function") {
    return Promise.resolve(value(...args));
  }
  return Promise.resolve(value);
};
function softDelete({
  deletedQuery = defaultQuery,
  removeData = defaultData
} = {}) {
  return async (context) => {
    const { service, method, params, app } = context;
    const { disableSoftDelete, query = {} } = params;
    if (app.version < "4.0.0") {
      throw new GeneralError2("The softDelete hook requires Feathers 4.0.0 or later");
    }
    checkContext(context, "before", null, "softDelete");
    if (disableSoftDelete) {
      return context;
    }
    const deleteQuery = await getValue(deletedQuery, context);
    context.params.query = Object.assign({}, query, deleteQuery);
    if (method === "remove") {
      const data = await getValue(removeData, context);
      const result = await service.patch(context.id, data, params);
      context.result = result;
    }
    return context;
  };
}

// src/hooks/stash-before.ts
import errors16 from "@feathersjs/errors";
var { BadRequest: BadRequest11 } = errors16;
function stashBefore(fieldName) {
  const beforeField = fieldName || "before";
  return (context) => {
    checkContext(context, "before", ["get", "update", "patch", "remove"], "stashBefore");
    if (context.params.disableStashBefore) {
      return context;
    }
    if ((context.id === null || context.id === void 0) && !context.params.query) {
      throw new BadRequest11("Id is required. (stashBefore)");
    }
    const params = context.method === "get" ? context.params : {
      provider: context.params.provider,
      authenticated: context.params.authenticated,
      user: context.params.user
    };
    return context.service.get(context.id, __spreadProps(__spreadValues({}, params), {
      query: params.query || {},
      disableStashBefore: true
    })).then((data) => {
      context.params[beforeField] = JSON.parse(JSON.stringify(data));
      return context;
    }).catch(() => context);
  };
}

// src/hooks/traverse.ts
function traverse3(transformer, getObject) {
  return (context) => {
    const items = typeof getObject === "function" ? getObject(context) : getObject || getItems(context);
    traverse(items, transformer);
    return context;
  };
}

// src/hooks/unless.ts
function unless(predicate, ...hooks2) {
  return iffElse(predicate, void 0, hooks2.slice());
}

// src/hooks/validate.ts
import errors17 from "@feathersjs/errors";
var { BadRequest: BadRequest12 } = errors17;
function validate(validator) {
  return (context) => {
    checkContext(context, "before", ["create", "update", "patch"], "validate");
    if (typeof validator !== "function") {
      throw new BadRequest12("Expected validator function. (validate)");
    }
    const results = validator(getItems(context), context);
    if (isPromise(results)) {
      return results.then((convertedValues) => {
        if (convertedValues) {
          replaceItems(context, convertedValues);
        }
        return context;
      });
    }
    if (results && Object.keys(results).length) {
      throw new BadRequest12({ errors: results });
    }
    return context;
  };
}

// src/hooks/validate-schema.ts
import errors18 from "@feathersjs/errors";
var { BadRequest: BadRequest13 } = errors18;
function validateSchema(schema, ajvOrAjv, options = { allErrors: true }) {
  const addNewError = (options == null ? void 0 : options.addNewError) || addNewErrorDflt;
  let ajv;
  let Ajv;
  if (typeof ajvOrAjv.addKeyword !== "function") {
    Ajv = ajvOrAjv;
    ajv = new Ajv(options);
  } else {
    ajv = ajvOrAjv;
  }
  const validate2 = typeof schema === "string" ? ajv.getSchema(schema) : ajv.compile(schema);
  return (context) => {
    const items = getItems(context);
    const itemsArray = Array.isArray(items) ? items : [items];
    const itemsLen = itemsArray.length;
    let errorMessages = null;
    let invalid = false;
    if (validate2.schema.$async) {
      return Promise.all(itemsArray.map((item, index) => {
        return validate2(item).catch((err) => {
          if (!(err instanceof ajv.constructor.ValidationError))
            throw err;
          invalid = true;
          addErrors(err.errors, index);
        });
      })).then(() => {
        if (invalid) {
          throw new BadRequest13("Data does not match schema", { errors: errorMessages });
        }
      });
    }
    itemsArray.forEach((item, index) => {
      if (!validate2(item)) {
        invalid = true;
        addErrors(validate2.errors, index);
      }
    });
    if (invalid) {
      throw new BadRequest13("Data does not match schema", { errors: errorMessages });
    }
    function addErrors(errors20, index) {
      errors20.forEach((ajvError) => {
        errorMessages = addNewError(errorMessages, ajvError, itemsLen, index);
      });
    }
  };
}
function addNewErrorDflt(errorMessages, ajvError, itemsLen, index) {
  const leader = itemsLen === 1 ? "" : `in row ${index + 1} of ${itemsLen}, `;
  let message;
  if (ajvError.dataPath) {
    message = `'${leader}${ajvError.dataPath.substring(1)}' ${ajvError.message}`;
  } else {
    message = `${leader}${ajvError.message}`;
    if (ajvError.params && ajvError.params.additionalProperty) {
      message += `: '${ajvError.params.additionalProperty}'`;
    }
  }
  return (errorMessages || []).concat(message);
}

// src/utils/calling-params.ts
import _get9 from "lodash/get";
import _set9 from "lodash/set";
var stndAuthProps = ["provider", "authenticated", "user"];
var defaults = {
  propNames: stndAuthProps,
  newProps: {}
};
function callingParamsDefaults(propNames, newProps) {
  if (propNames) {
    defaults.propNames = Array.isArray(propNames) ? propNames : [propNames];
  }
  if (newProps) {
    defaults.newProps = newProps;
  }
}
function callingParams({
  query,
  propNames = [],
  newProps = {},
  hooksToDisable = [],
  ignoreDefaults
} = {}) {
  return (context) => {
    propNames = Array.isArray(propNames) ? propNames : [propNames];
    hooksToDisable = Array.isArray(hooksToDisable) ? hooksToDisable : [hooksToDisable];
    const newParams = query ? { query } : {};
    const allPropNames = ignoreDefaults ? propNames : [...defaults.propNames, ...propNames];
    allPropNames.forEach((name) => {
      if (name) {
        const value = _get9(context.params, name);
        if (value !== void 0) {
          _set9(newParams, name, value);
        }
      }
    });
    Object.assign(newParams, ignoreDefaults ? {} : defaults.newProps, newProps);
    hooksToDisable.forEach((name) => {
      switch (name) {
        case "populate":
        case "fastJoin":
          newParams._populate = "skip";
          break;
        case "softDelete":
          newParams.query = newParams.query || {};
          newParams.query.$disableSoftDelete = true;
          break;
        case "softDelete2":
          newParams.$disableSoftDelete2 = true;
          break;
        case "ignoreDeletedAt":
          newParams.$ignoreDeletedAt = true;
          break;
        case "stashBefore":
          newParams.disableStashBefore = true;
          break;
      }
    });
    return newParams;
  };
}
function makeCallingParams(context, query, include, inject = {}) {
  return callingParams({
    query,
    propNames: include === void 0 ? ["provider", "authenticated", "user"] : Array.isArray(include) ? include : [include],
    newProps: Object.assign({}, { _populate: "skip" }, inject),
    ignoreDefaults: true
  })(context);
}

// src/utils/every.ts
function every(...predicates) {
  return async function(...fnArgs) {
    const promises = predicates.map((fn) => fn.apply(this, fnArgs));
    const results = await Promise.all(promises);
    return await Promise.resolve(results.every((result) => !!result));
  };
}

// src/utils/is-not.ts
import errors19 from "@feathersjs/errors";
var { MethodNotAllowed: MethodNotAllowed3 } = errors19;
function isNot(predicate) {
  if (typeof predicate !== "function") {
    throw new MethodNotAllowed3("Expected function as param. (isNot)");
  }
  return (context) => {
    const result = predicate(context);
    if (!isPromise(result)) {
      return !result;
    }
    return result.then((result1) => !result1);
  };
}

// src/utils/params-for-server.ts
function paramsForServer(params, ...whitelist) {
  const ifWhitelist = !!whitelist.length;
  const _params = Object.assign({}, params);
  _params.query = _params.query || {};
  _params.query.$client = _params.query.$client || {};
  Object.keys(_params).forEach((key) => {
    if (key !== "query") {
      if (!ifWhitelist || whitelist.includes(key)) {
        _params.query.$client[key] = _params[key];
      }
      delete _params[key];
    }
  });
  return _params;
}

// src/utils/some.ts
function some(...predicates) {
  return async function(context) {
    const promises = predicates.map((fn) => fn.apply(this, [context]));
    const results = await Promise.all(promises);
    return await Promise.resolve(results.some((result) => !!result));
  };
}
export {
  actOnDefault,
  actOnDispatch,
  alterItems,
  cache,
  callingParams,
  callingParamsDefaults,
  checkContext,
  checkContextIf,
  combine,
  dePopulate,
  debug,
  disablePagination,
  disallow,
  discard,
  discardQuery,
  every,
  fastJoin,
  fgraphql,
  getItems,
  iff,
  iffElse,
  isNot,
  isProvider,
  keep,
  keepInArray,
  keepQuery,
  keepQueryInArray,
  lowerCase,
  makeCallingParams,
  mongoKeys,
  paramsForServer,
  paramsFromClient,
  populate,
  preventChanges,
  replaceItems,
  required,
  runHook,
  runParallel,
  sequelizeConvert,
  serialize,
  setField,
  setNow,
  setSlug,
  sifter,
  softDelete,
  some,
  stashBefore,
  traverse3 as traverse,
  unless,
  validate,
  validateSchema,
  iff as when
};
