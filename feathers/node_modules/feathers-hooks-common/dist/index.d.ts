import * as _feathersjs_feathers from '@feathersjs/feathers';
import { Hook, HookContext, Application, Query, Paginated, Params } from '@feathersjs/feathers';
import { Ajv, Options, ErrorObject } from 'ajv';
import { GraphQLFieldResolver, parse } from 'graphql';

/**
 * Runs a series of hooks which mutate context.data or context.result (the Feathers default).
 * {@link https://hooks-common.feathersjs.com/hooks.html#actondefault}
 */
declare const actOnDefault: (...hooks: Hook[]) => Hook<any, _feathersjs_feathers.Service<any>>;
/**
 * Runs a series of hooks which mutate context.dispatch.
 * {@link https://hooks-common.feathersjs.com/hooks.html#actondispatch}
 */
declare const actOnDispatch: (...hooks: Hook[]) => Hook<any, _feathersjs_feathers.Service<any>>;

/**
 * Make changes to data or result items. Very flexible.
 * {@link https://hooks-common.feathersjs.com/hooks.html#alteritems}
 */
declare function alterItems<T = any>(cb: (record: T, context: HookContext<T>) => any): Hook;

declare type HookType = 'before' | 'after' | 'error';
declare type MethodName = 'find' | 'create' | 'get' | 'update' | 'patch' | 'remove';
declare type TransportName = 'socketio' | 'primus' | 'rest' | 'external' | 'server';
declare type Disablable = 'populate' | 'fastJoin' | 'ignoreDeletedAt' | 'softDelete' | 'softDelete2' | 'stashBefore';
declare type SyncContextFunction<T> = (context: HookContext) => T;
declare type AsyncContextFunction<T> = (context: HookContext) => Promise<T>;
declare type ContextFunction<T> = (context: HookContext) => T | Promise<T>;
declare type SyncPredicateFn = SyncContextFunction<boolean>;
declare type AsyncPredicateFn = AsyncContextFunction<boolean>;
declare type PredicateFn = ContextFunction<boolean>;
declare type CacheMap<T> = Map<string, T>;
interface CacheOptions<T, K> {
    clone?(item: T): T;
    makeCacheKey?(id: K): string;
}
interface CallingParamsOptions {
    /**
     * The params.query for the calling params.
     */
    query?: any;
    /**
     * The names of the props in context.params to include in the new params.
     */
    propNames?: string[];
    /**
     * Additional props to add to the new params.
     */
    newProps?: any;
    /**
     * The names of hooks to disable during the service call. populate, fastJoin, softDelete and stashBefore are supported.
     */
    hooksToDisable?: Disablable[] | Disablable;
    /**
     *    Ignore the defaults propNames and newProps.
     */
    ignoreDefaults?: boolean;
}
interface ResolverContext<T = any> extends HookContext<T> {
    _loaders: any;
}
declare type SimpleResolver<T> = (...args: any[]) => (item: T, context: ResolverContext) => Promise<any>;
interface RecursiveResolver<T> {
    resolver: SimpleResolver<T>;
    joins: ResolverMap<any>;
}
interface ResolverMap<T> {
    after?: (context: ResolverContext) => void | Promise<void>;
    before?: (context: ResolverContext) => void | Promise<void>;
    joins: {
        [property: string]: SimpleResolver<T> | RecursiveResolver<T>;
    };
}
declare type FGraphQLResolverMapFactory = (app: Application, runtime: any) => FGraphQLResolverMap;
interface FGraphQLResolverMap {
    [i: string]: {
        [i: string]: GraphQLFieldResolver<any, any>;
    };
    Query: {
        [i: string]: GraphQLFieldResolver<any, any>;
    };
}
interface FGraphQLOptions {
    skipHookWhen?: SyncContextFunction<boolean>;
    inclAllFieldsServer?: boolean;
    inclAllFieldsClient?: boolean;
    inclAllFields?: boolean;
    inclJoinedNames?: boolean;
    extraAuthProps?: string[];
}
interface FGraphQLHookOptions {
    recordType: string;
    schema: string;
    resolvers: FGraphQLResolverMap | FGraphQLResolverMapFactory;
    query: Query | SyncContextFunction<Query>;
    options?: FGraphQLOptions;
    runTime: any;
    parse: typeof parse;
}
interface PopulateOptions {
    schema: Partial<PopulateSchema> | ((context: HookContext, options: PopulateOptions) => Partial<PopulateSchema>);
    checkPermissions?: (context: HookContext, path: string, permissions: any, depth: number) => boolean;
    profile?: boolean;
}
interface PopulateSchema {
    /**
     * The name of the service providing the items, actually its path.
     */
    service: string;
    /**
     * Where to place the items from the join
     * dot notation
     */
    nameAs: string;
    /**
     * The name of the field in the parent item for the relation.
     * dot notation
     */
    parentField: string;
    /**
     * The name of the field in the child item for the relation.
     * Dot notation is allowed and will result in a query like { 'name.first': 'John' } which is not suitable for all DBs.
     * You may use query or select to create a query suitable for your DB.
     */
    childField: string;
    /**
     * Who is allowed to perform this join. See checkPermissions above.
     */
    permissions: any;
    /**
     * An object to inject into context.params.query.
     */
    query: any;
    /**
     * A function whose result is injected into the query.
     */
    select: (context: HookContext, parentItem: any, depth: number) => any;
    /**
     * Force a single joined item to be stored as an array.
     */
    asArray: boolean;
    /**
     * Controls pagination for this service.
     */
    paginate: boolean | number;
    /**
     * Perform any populate or fastJoin registered on this service.
     */
    useInnerPopulate: boolean;
    /**
     * Call the service as the server, not with the clientâ€™s transport.
     */
    provider: string;
    include: Partial<PopulateSchema> | Partial<PopulateSchema>[];
}
interface SerializeSchema {
    only?: string | string[];
    exclude?: string | string[];
    computed?: {
        [propName: string]: (record: any, context: HookContext) => any;
    };
    [key: string]: SerializeSchema | SerializeSchema['computed'] | string | string[] | undefined;
}
interface SequelizeConversion {
    js: (sqlValue: any) => any;
    sql: (jsValue: any) => any;
}
interface SequelizeConverts<C> {
    [name: string]: keyof C | 'boolean' | 'date' | 'json';
}
declare type SoftDeleteOptionFunction = (context?: HookContext) => Promise<{
    [key: string]: any;
}>;
interface SoftDeleteOptions {
    deletedQuery?: {
        [key: string]: any;
    } | SoftDeleteOptionFunction;
    removeData?: {
        [key: string]: any;
    } | SoftDeleteOptionFunction;
}
declare type SyncValidatorFn = (values: any, context: HookContext) => {
    [key: string]: string;
} | null;
declare type AsyncValidatorFn = (values: any, context: HookContext) => Promise<object | null>;
declare type ValidatorFn = SyncValidatorFn | AsyncValidatorFn;
declare type AjvOrNewable = Ajv | (new (options?: Options) => Ajv);
interface ValidateSchemaOptions extends Options {
    /**
     * The hook will throw if the data does not match the JSON-Schema. error.errors will, by default, contain an array
     * of error messages. You may change this with a custom formatting function. Its a reducing function which works
     * similarly to Array.reduce().
     */
    addNewError: (currentFormattedMessages: any, ajvErrorObject: ErrorObject, itemsLen: number, itemIndex: number) => any;
}
interface IffHook extends Hook {
    else(...hooks: Hook[]): Hook;
}
interface SetFieldOptions {
    as: string;
    from: string;
    allowUndefined?: boolean;
}

/**
 * Persistent, most-recently-used record cache for services.
 * {@link https://hooks-common.feathersjs.com/hooks.html#cache}
 */
declare function cache<T, K extends keyof T>(cacheMap: CacheMap<T>, keyField?: K, options?: CacheOptions<T, K>): Hook;

/**
 * Like checkContext, but only if the given type matches the hook's type.
 * Restrict a hook to run for certain methods and method types. (Utility function.)
 * {@link https://hooks-common.feathersjs.com/hooks.html#checkcontextif}
 */
declare function checkContextIf(context: HookContext, type: HookType, methods: MethodName | MethodName[] | null, label: string): void;

/**
 * Display the current hook context for debugging.
 * {@link https://hooks-common.feathersjs.com/hooks.html#debug}
 */
declare function debug(msg: string, ...fieldNames: string[]): Hook;

/**
 * Remove records and properties created by the populate hook.
 * {@link https://hooks-common.feathersjs.com/hooks.html#depopulate}
 */
declare function dePopulate(func?: any): Hook;

/**
 * Disables pagination when query.$limit is -1 or '-1'.
 * {@link https://hooks-common.feathersjs.com/hooks.html#disablepagination}
 */
declare function disablePagination(): Hook;

/**
 * Prevents access to a service method completely or for specific transports.
 * {@link https://hooks-common.feathersjs.com/hooks.html#disallow}
 */
declare function disallow(...transports: TransportName[]): Hook;

/**
 * Delete certain fields from the record(s).
 * {@link https://hooks-common.feathersjs.com/hooks.html#discard}
 */
declare function discard(...fieldNames: string[]): Hook;

/**
 * Delete certain fields from the query object.
 * {@link https://hooks-common.feathersjs.com/hooks.html#discardquery}
 */
declare function discardQuery(...fieldNames: string[]): Hook;

/**
 * We often want to combine rows from two or more tables based on a relationship between them. The fastJoin hook
 * will select records that have matching values in both tables. It can batch service calls and cache records,
 * thereby needing roughly an order of magnitude fewer database calls than the populate hook, i.e. 2 calls instead
 * of 20. It uses a GraphQL-like imperative API.
 *
 * fastJoin is not restricted to using data from Feathers services. Resources for which there are no Feathers
 * adapters can also be used.
 *
 *
 * fastJoin(postResolvers)
 * fastJoin(postResolvers, query)
 * fastJoin(context => postResolvers)
 * fastJoin(postResolvers, context => query) // supports queries from client
 * {@link https://hooks-common.feathersjs.com/hooks.html#fastjoin}
 */
declare function fastJoin(resolvers: ResolverMap<any> | SyncContextFunction<ResolverMap<any>>, query?: Query | SyncContextFunction<Query>): Hook;

/**
 * Generate Graphql Resolvers for services
 * {@link https://medium.com/@eddyystop/38faee75dd1}
 */
declare function fgraphql(options1: FGraphQLHookOptions): Hook;

/**
 * Execute one or another series of hooks depending on a sync or async predicate.
 * {@link https://hooks-common.feathersjs.com/hooks.html#iff}
 */
declare function iff(predicate: boolean | PredicateFn, ...hooks: Hook[]): IffHook;

/**
 * Execute one array of hooks or another based on a sync or async predicate.
 * {@link https://hooks-common.feathersjs.com/hooks.html#iffelse}
 */
declare function iffElse(predicate: boolean | PredicateFn, trueHooks: Hook | Hook[] | undefined, falseHooks?: Hook | Hook[] | undefined): Hook;

/**
 * Check which transport provided the service call.
 * {@link https://hooks-common.feathersjs.com/hooks.html#isprovider}
 */
declare function isProvider(...providers: TransportName[]): SyncContextFunction<boolean>;

/**
 * Keep certain fields in the record(s), deleting the rest.
 * {@link https://hooks-common.feathersjs.com/hooks.html#keep}
 */
declare function keep(...fieldNames: string[]): Hook;

/**
 * Keep certain fields in a nested array inside the record(s), deleting the rest.
 * {@link https://hooks-common.feathersjs.com/hooks.html#keepinarray}
 */
declare function keepInArray(arrayName: string, fieldNames: string[]): Hook;

/**
 * Keep certain fields in the query object, deleting the rest.
 * {@link https://hooks-common.feathersjs.com/hooks.html#keepquery}
 */
declare function keepQuery(...fieldNames: string[]): Hook;

/**
 * Keep certain fields in a nested array inside the query object, deleting the rest.
 * {@link https://hooks-common.feathersjs.com/hooks.html#keepqueryinarray}
 */
declare function keepQueryInArray(arrayName: string, fieldNames: string[]): Hook;

/**
 * Convert certain field values to lower case.
 * {@link https://hooks-common.feathersjs.com/hooks.html#lowercase}
 */
declare function lowerCase(...fieldNames: string[]): Hook;

/**
 * Wrap MongoDB foreign keys in ObjectId.
 * {@link https://hooks-common.feathersjs.com/hooks.html#mongokeys}
 */
declare function mongoKeys(ObjectId: new (id?: string | number) => any, keyFields: string | string[]): Hook;

/**
 * Pass context.params from client to server. Server hook.
 * {@link https://hooks-common.feathersjs.com/hooks.html#paramsfromclient}
 */
declare function paramsFromClient(...whitelist: string[]): Hook;

declare function populate(options: PopulateOptions): Hook;

/**
 * Prevent patch service calls from changing certain fields.
 * {@link https://hooks-common.feathersjs.com/hooks.html#preventchanges}
 */
declare function preventChanges(ifThrow: boolean, ...fieldNames: string[]): Hook;

/**
 * Check selected fields exist and are not falsey. Numeric 0 is acceptable.
 * {@link https://hooks-common.feathersjs.com/hooks.html#required}
 */
declare function required(...fieldNames: string[]): Hook;

/**
 * Let's you call a hook right after the service call. (Utility function.)
 * {@link https://hooks-common.feathersjs.com/hooks.html#runhook}
 */
declare function runHook(context?: HookContext): (hook: Hook) => (data: any[] | Paginated<any>) => Promise<any>;

/**
 * Run a hook in parallel to the other hooks and the service call.
 * {@link https://hooks-common.feathersjs.com/hooks.html#runparallel}
 */
declare function runParallel<T = any>(hook: Hook, clone: (item: T) => T, cloneDepth?: number): Hook;

/**
 * {@link https://hooks-common.feathersjs.com/hooks.html#sequelizeconvert}
 */
declare function sequelizeConvert<C extends {
    [name: string]: SequelizeConversion;
}>(converts: SequelizeConverts<C> | null | undefined | false, ignores?: string[] | null | undefined | false, conversions?: C): Hook;

/**
 * Prune values from related records. Calculate new values.
 * {@link https://hooks-common.feathersjs.com/hooks.html#serialize}
 */
declare function serialize(schema1: SerializeSchema | SyncContextFunction<SerializeSchema>): Hook;

/**
 * The `setField` hook allows to set a field on the hook context based on the value of another field on the hook context.
 * {@link https://hooks-common.feathersjs.com/hooks.html#setfield}
 */
declare function setField({ as, from, allowUndefined }: SetFieldOptions): Hook;

/**
 * Create/update certain fields to the current date-time.
 * {@link https://hooks-common.feathersjs.com/hooks.html#setnow}
 */
declare function setNow(...fieldNames: string[]): Hook;

/**
 * Fix slugs in URL, e.g. /stores/:storeId.
 * {@link https://hooks-common.feathersjs.com/hooks.html#setslug}
 */
declare function setSlug(slug: string, fieldName?: string): Hook;

declare function sifter(siftFunc: SyncContextFunction<(item: any) => boolean>): Hook;

/**
 * Allow to mark items as deleted instead of removing them.
 */
declare function softDelete({ deletedQuery, removeData }?: SoftDeleteOptions): (context: any) => Promise<any>;

/**
 * Stash current value of record, usually before mutating it. Performs a get call.
 * {@link https://hooks-common.feathersjs.com/hooks.html#stashbefore}
 */
declare function stashBefore(fieldName?: string): Hook;

/**
 * Transform fields & objects in place in the record(s) using a recursive walk. Powerful.
 * Check docs at https://github.com/substack/js-traverse for info on transformContext!
 * {@link https://hooks-common.feathersjs.com/hooks.html#traverse}
 */
declare function traverse(transformer: (this: any, transformContext: any) => any, getObject?: SyncContextFunction<any>): Hook;

/**
 * Execute a series of hooks if a sync or async predicate is falsey.
 * {@link https://hooks-common.feathersjs.com/hooks.html#unless}
 */
declare function unless(predicate: boolean | PredicateFn, ...hooks: Hook[]): Hook;

/**
 * Validate data using a validation function.
 * {@link https://hooks-common.feathersjs.com/hooks.html#validate}
 */
declare function validate(validator: ValidatorFn): Hook;

/**
 * Validate data using JSON-Schema.
 * {@link https://hooks-common.feathersjs.com/hooks.html#validateschema}
 */
declare function validateSchema(schema: object | string, ajvOrAjv: AjvOrNewable, options?: ValidateSchemaOptions): Hook;

/**
 * Set defaults for building params for service calls with callingParams. (Utility function.)
 * {@link https://hooks-common.feathersjs.com/hooks.html#callingparamsdefaults}
 */
declare function callingParamsDefaults(propNames: string[], newProps?: any): void;
/**
 * Build params for a service call. (Utility function.)
 * {@link https://hooks-common.feathersjs.com/hooks.html#callingparams}
 */
declare function callingParams({ query, propNames, newProps, hooksToDisable, ignoreDefaults }?: CallingParamsOptions): SyncContextFunction<Params>;
/**
 * You should prefer using the callingParams utility to makeCallingParams.
 * Build context.params for service calls. (Utility function.)
 * {@link https://hooks-common.feathersjs.com/hooks.html#makecallingparams}
 */
declare function makeCallingParams(context: HookContext, query?: any, include?: string | string[], inject?: {}): Params;

/**
 * Restrict a hook to run for certain methods and method types. (Utility function.)
 * {@link https://hooks-common.feathersjs.com/hooks.html#checkcontext}
 */
declare function checkContext(context: HookContext, type?: HookType | HookType[] | null, methods?: MethodName | MethodName[] | null, label?: string): void;

/**
 * Sequentially execute multiple sync or async hooks.
 * {@link https://hooks-common.feathersjs.com/hooks.html#combine}
 */
declare function combine(...serviceHooks: Hook[]): Hook;

/**
 * Return the and of a series of sync or async predicate functions.
 * {@link https://hooks-common.feathersjs.com/hooks.html#every}
 */
declare function every(...predicates: PredicateFn[]): AsyncPredicateFn;

/**
 * Get the records in context.data or context.result[.data]. (Utility function.)
 * {@link https://hooks-common.feathersjs.com/hooks.html#getitems}
 */
declare function getItems(context: HookContext): any;

/**
 * Negate a sync or async predicate function.
 * {@link https://hooks-common.feathersjs.com/hooks.html#isnot}
 */
declare function isNot(predicate: boolean | PredicateFn): PredicateFn;

/**
 * Pass an explicit context.params from client to server. Client-side. (Utility function.)
 * {@link https://hooks-common.feathersjs.com/hooks.html#ParamsForServer}
 */
declare function paramsForServer(params?: Params, ...whitelist: string[]): Params;

/**
 * Replace the records in context.data or context.result[.data]. (Utility function.)
 * {@link https://hooks-common.feathersjs.com/hooks.html#replaceitems}
 */
declare function replaceItems(context: HookContext, items: any): void;

/**
 * Return the or of a series of sync or async predicate functions.
 * {@link https://hooks-common.feathersjs.com/hooks.html#some}
 */
declare function some(...predicates: PredicateFn[]): AsyncPredicateFn;

export { AjvOrNewable, AsyncContextFunction, AsyncPredicateFn, AsyncValidatorFn, CacheMap, CacheOptions, CallingParamsOptions, ContextFunction, Disablable, FGraphQLHookOptions, FGraphQLOptions, FGraphQLResolverMap, FGraphQLResolverMapFactory, HookType, IffHook, MethodName, PopulateOptions, PopulateSchema, PredicateFn, RecursiveResolver, ResolverContext, ResolverMap, SequelizeConversion, SequelizeConverts, SerializeSchema, SetFieldOptions, SimpleResolver, SoftDeleteOptionFunction, SoftDeleteOptions, SyncContextFunction, SyncPredicateFn, SyncValidatorFn, TransportName, ValidateSchemaOptions, ValidatorFn, actOnDefault, actOnDispatch, alterItems, cache, callingParams, callingParamsDefaults, checkContext, checkContextIf, combine, dePopulate, debug, disablePagination, disallow, discard, discardQuery, every, fastJoin, fgraphql, getItems, iff, iffElse, isNot, isProvider, keep, keepInArray, keepQuery, keepQueryInArray, lowerCase, makeCallingParams, mongoKeys, paramsForServer, paramsFromClient, populate, preventChanges, replaceItems, required, runHook, runParallel, sequelizeConvert, serialize, setField, setNow, setSlug, sifter, softDelete, some, stashBefore, traverse, unless, validate, validateSchema, iff as when };
